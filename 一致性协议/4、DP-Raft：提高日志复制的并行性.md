# 4、DP-Raft：提高日志复制的并行性
- 原文：[Notes/论文原文/4、DP-Raft：提高日志复制的并行性.pdf at master · LYuYang61/Notes · GitHub](https://github.com/LYuYang61/Notes/blob/master/%E8%AE%BA%E6%96%87%E5%8E%9F%E6%96%87/4%E3%80%81DP-Raft%EF%BC%9A%E6%8F%90%E9%AB%98%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6%E7%9A%84%E5%B9%B6%E8%A1%8C%E6%80%A7.pdf)
### 1、简介
#### 1.1 Raft 的局限性
- 要求日志必须**顺序确认、顺序提交、顺序应用**，并且不允许存在日志空洞
- 高并发事务场景下，日志复制成为系统性能瓶颈
- 网络状况不佳时，follower 可能无法及时接收日志条目并回复 leader，阻塞整个复制流程
#### 1.2 现有改进方案的不足
- **PolarFS**：
	- 为文件系统设计的，不保证并发命令的完成顺序，不满足事务的提交语义，不能直接应用于OLTP 数据库系统
    - 通过 LBA（逻辑块地址）检测冲突，如果 N（允许的最大日志洞大小）太大，则会增加日志条目的大小，浪费带宽
- **TiDB**：
    - 将数据划分为分区，每个分区都是要复制的单个Raft组
    - 跨分片事务处理复杂，无法解决单分片内并发问题

### 2、理解日志依赖以实现并行性
- 事务之间可能存在四种主要依赖关系，它们对日志的并行提交和应用有着不同的影响
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20250822160909.png)
- Ti 表示事务，Li 作为事务 Ti 的日志条目
- 对于每个事务，我们生成一个日志条目来记录事务的结果
#### 2.1 写后写 WAW
- **定义**：当事务 T 2​ 写入了事务 T 1​ 已经修改过的数据时，就存在 WAW 依赖
- WAW 依赖的日志可以**并行提交**：
	- 如果 L 1​ 和 L 2​ 都已提交，无论它们的提交顺序如何，只要在应用时遵循正确的顺序（即 L 1​ 在 L 2​ 之前），就能达到一致的状态
	- 即使其中一个提交失败，也可以将其忽略，应用后的状态仍然保持一致
- WAW 依赖的日志**不能乱序应用**：
	- 根据事务的执行顺序，L 2​ 的结果必须在 L 1​ 之后写入
	- 如果先应用 L 2​，然后 L 1​ 覆盖了 L 2​ 的更新结果，将导致不正确的状态
- WAW 依赖是决定日志**应用顺序**的关键
#### 2.2 写后读 RAW
- **定义**：当事务 T 4​ 读取了事务 T 3​ 写入的结果时，就存在 RAW 依赖
- RAW 依赖的日志**不能乱序提交**：
	- L 4​ 不能在 L 3​ 之前提交，如果 L 4​ 先提交而 L 3​ 提交失败，那么 T 4​ 将读取到一个从未存在的数据【脏读（Dirty Read）】
- RAW 依赖的日志可以**并行应用**：
	- 一旦 T 3​ 和 T 4​ 都已按顺序提交，并且它们不更新相同的数据，它们的具体应用顺序不会导致不一致的状态
- RAW 依赖是决定日志**提交顺序**的关键
#### 2.3 读后写 WAR
- **定义**：当事务 T 6​ 更新了事务 T 5​ 之前读取过的数据时，就存在 WAR 依赖
- WAR 依赖的日志可以**并行提交**：
	- T 5​ 已经读取了它需要的数据，所以 T 6​ 的更新不会影响 T 5​ 的结果，它们可以无序提交
- WAR 依赖的日志可以**并行应用**：
	- 由于它们更新的数据不同，它们也可以以任何顺序应用
#### 2.4 无依赖 NULL
- **定义**：如果两个事务不读取或写入相同的数据，则它们之间没有依赖关系。  
- 无依赖的日志可以**并行提交**
- 无依赖的日志可以**并行应用**
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20250825105331.png)

### 3、DP-Raft 架构
- 为了在支持并行复制的同时保留日志依赖关系，DP-Raft引入了经过修改的日志缓冲区和日志条目数据结构
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20250825103806.png)
#### 3.1 日志缓冲区
- DP-Raft 中的每个节点（包括 leader 和 follower）都使用一个**环形缓冲区**来存储日志条目
- 与标准 Raft 不同，DP-Raft 明确允许**日志空洞**的存在
- 在 **follower 节点**上，日志空洞表示某个日志条目是空的，但其前后存在非空的日志条目
- 在 **leader 节点**上，日志空洞则表示已提交日志条目之间存在未提交的条目
- 无限制地允许日志空洞会带来两个主要问题：  
	1. **写入集维护开销过大**：如果不限制日志空洞的范围，系统需要维护空洞日志条目及其所有依赖条目的写入集
	2. **状态维护复杂性高**：由于空洞的存在，无法像 Raft 那样简单地使用一个 commitIndex 来表示该索引之前所有条目的状态，系统需要记录所有条目的具体状态
- 为了解决这些问题，DP-Raft 引入了**滑动窗口**机制：
	- DP-Raft 只允许日志空洞存在于一个可配置大小的滑动窗口内，有效地限制了需要复杂状态维护的条目范围
	- **WindowHead：**
		- 在 leader 节点上，windowHead **表示第一个未提交的条目**，同时也是 follower 节点上可能存在空洞条目的起始点
		- WindowHead 之前的所有条目都被保证已提交，这与 Raft 中的 commitIndex 类似
	- 当一个条目及其之前的所有条目都已提交时，windowHead 可以向前移动
	- 即使窗口内某个较早的条目尚未提交，如果 leader 收到了某个较晚条目（例如 Entry 2）的多数确认，该条目也可以被提交。此时，较早的未提交条目（例如 Entry 1）就会成为一个日志空洞
#### 3.2 日志条目
- **日志序列号 (LSN - Log Sequence Number)**：每个日志条目都拥有一个唯一的、单调递增的 LSN，它同时用作 DP-Raft 的日志条目索引
- **事务 ID (TransID)**：标识与该日志条目关联的事务
- **日志数据 (Log Data)**：存储事务执行的结果，具体指示哪些数据被修改及其新值。DP-Raft 采用了类似于“值日志”（value log）的方式来记录这些信息
- **状态 (Status)**：指示该条目是否已 committed（已提交）和 applied（已应用）
- **WAW 依赖 (WAW Dependency)**：存储当前日志条目所依赖的 WAW 日志条目的 LSN（索引）
- **RAW 依赖 (RAW Dependency)**：存储当前日志条目所依赖的 RAW 日志条目的 LSN（索引）

### 4、并行复制过程
#### 4.1 Follower 并行确认
- 在 Raft 中，当 follower 收到追加日志条目的请求时，它必须通过检查其日志的最新条目与 leader 发送的信息是否一致来确保日志的匹配性，只有在检查成功后，follower 才能接受新的日志条目
- DP-Raft 取消了这一严格的顺序限制：即使日志缓冲区中存在空洞，follower 也无需等待
- 当 follower 从 leader 那里收到新的日志条目时，它会**直接根据条目的日志序列号（LSN）将其添加到自己的日志缓冲区中**，然后立即发送确认回执给 leader
- 这种设计显著减少了额外的等待时间，即使在网络抖动或日志条目乱序到达的情况下，也能大幅降低日志复制的延迟
- DP-Raft 跳过检查阶段，直接保存条目（如果前一个条目缺失），但会存储前一个条目的相关信息
- 当前一个条目稍后到达时，它会与之前存储的信息进行比较，如果发现不匹配，则后面冲突的条目将被丢弃
- 这种机制确保了 follower 最终不会拥有与 leader 不同的日志条目，从而维护了日志的一致性
#### 4.2 Leader 并行提交
- 并行提交必须遵循 RAW 依赖的顺序：**在提交一个条目之前，leader 必须确保所有该条目所依赖的 RAW 依赖条目都已提交（或已应用）**
- 这一检查对于防止“脏读”并维护事务提交语义至关重要：
	- Leader 首先检查当前条目是否已获得多数确认，然后遍历其所有 RAW 依赖条目，确保它们的状态为“已提交”或“已应用”
	- 只有当所有 RAW 依赖都满足后，当前条目才能被标记为“已提交” 
- 与 ParallelRaft 不同，ParallelRaft 不保证依赖条目之间的提交顺序
- DP-Raft 引入了一个 commitFlag（提交标志）来表示滑动窗口中条目的提交状态
- CommitFlag 是一个位图，其中每个位代表滑动窗口中一个条目的状态（1 表示已提交，0 表示未提交）
- Leader 在提交条目后会更新 commitFlag，将相应位设为 1 
- 由于  commitFlag 在并行提交时是一个高竞争资源，DP-Raft 使用原子 CAS（Compare-And-Swap）操作来修改它，以减少互斥锁上的冲突，从而提高效率 
- 下次 leader 追加条目或发送心跳时， commitFlag 和 windowHead 会一同发送给 follower，告知它们哪些条目已提交，以便 follower 可以将其应用到状态机中
#### 4.3 Follower 并行应用
- Follower 收到 commitFlag 和 windowHead 后，会检查日志条目的状态
- 对于  windowHead 之前的条目（表示它们已提交），如果其中一些仍然缺失，follower 会通知 leader 重新发送缺失的条目，以填补日志空洞
- 对于滑动窗口中的条目，follower 将根据  commitFlag 更新其状态，如果一个条目被标记为“已提交”，则可以应用它
- DP-Raft 允许 follower 根据每个条目中的依赖信息并行应用条目
- **在应用一个条目之前，follower 必须确保所有该条目所依赖的 WAW 依赖日志条目都已应用**
- 如果所有 WAW 依赖都满足，该条目就可以被应用；否则，它需要等待依赖条目完成应用
- 通过保留依赖关系并根据 WAW 依赖顺序应用写入冲突的条目，DP-Raft 确保了状态机的正确性

### 5、领导者选举
- 在 DP-Raft 中，由于允许日志空洞，新选举出的 leader 可能丢失一些已提交的条目
- 为了解决这一问题，DP-Raft 引入了“预领导者”（pre-leader）状态
- 当一个候选者获得多数投票后，它不会立即成为真正的 leader 并提供服务，而是首先进入“预领导者”状态
- **预领导者必须首先进行一个额外的“合并阶段”**，通过从其他服务器收集缺失的条目来填补其日志中的所有空洞，然后才能转换为“真正”的 leader 并提供服务
#### 5.1 投票请求
- Follower 转换为候选者并发送投票请求时，除了包含其最新日志条目的任期和索引之外，DP-Raft 还会包含候选者**第一个未提交日志条目的索引**
- **投票约束**：
	1. **检查日志新旧程度**：
		- Follower 首先检查候选者的最新日志条目的任期和索引是否至少与自身日志一样新
		- 如果候选者日志更新，则授予投票；如果候选者日志落后，则拒绝投票；如果两者日志一样新，则应用第二个约束
		- 这个约束确保了被选举的预领导者的日志至少与多数服务器中的日志一样新，并且只有一个预领导者会被选举出来，从而满足Raft的“选举安全性”属性
	2. **日志完整性**：
		- 如果候选者的“第一个未提交索引”小于 follower 本地的“第一个未提交条目索引”，follower 会拒绝投票；否则，授予投票
		- 这个约束的目的是确保需要合并的日志条目数量尽可能小
		- 例如，如果一个 follower 虽然拥有最新的日志条目，但其日志中存在大量的空洞（因为它落后于之前的 leader），那么选举它为预领导者将导致大量的日志合并操作，浪费网络带宽并增加合并时间
#### 5.2 日志合并
- 在获得多数投票后，预领导者会进入日志合并阶段。它会向其他多数服务器请求日志条目，特别是那些位于其“第一个未提交索引”和“最新索引”之间的条目
- 合并过程根据日志条目的不同状态和在不同服务器上的存在情况，遵循以下七种条件和决策
- **已提交条目**：
    - **条件 1 本地已提交**：如果预领导者上的条目已存在且已提交，则直接使用本地条目
    - **条件 2 和 5 本地未提交或缺失，但在其他节点已提交**：如果预领导者上的已提交条目未提交或缺失，但至少在一个其他服务器上已提交，则预领导者会将该已提交条目合并到其本地日志中，这确保了所有已提交的条目最终都会 leader 拥有
- **未提交条目**：
    - **条件 3 本地存在，其他节点缺失**：如果预领导者持有某个未提交条目，但所有其他服务器上都缺失该条目，则预领导者会保留该条目。这可能是因为该条目已被复制到多数服务器并已提交，但尚未通知 follower 提交，而此时包括领导者在内的一些服务器发生故障。在这种情况下，预领导者是唯一幸存并拥有该条目的服务器，因此该条目不能被放弃
    - **条件 6 本地和所有其他节点都缺失**：如果一个条目在预领导者和所有其他服务器上都缺失，这意味着它无法被提交，因此可以忽略并将其设置为 NULL
    - **条件 4 和 7 未提交且在不同服务器上不同**：如果一个条目未提交且在不同服务器上存在差异，预领导者将选择具有最高任期（term）的条目

![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20250825124041.png)
- S 1-S 5 代表不同的服务器，粗体数字表示已提交条目，普通数字表示未提交条目
- S 3 在 term 2 时是领导者，但在 t 1 失败
- S 4 随后成为领导者，并复制了条目 8 和9
- 在 t 2，S 4 失败，S 1 发起领导者选举并被 S 2 和 S 5 投票，成为预领导者
- S 1 从其他服务器获取了条目 4 到 9 之间的日志后开始合并
- 条目 4 在 S 1 本地缺失但在 S 5 已提交，S 1 会合并 S 5 的条目4
- 条目 5 在 S 1 本地已提交，则跳过
- 条目 6 在所有三台服务器上都缺失，被设为 NULL 并忽略
- 条目 7 只存在于预领导者 S 1，因此被保留
- 对于条目 8 和 9，不同服务器持有不同的条目，因此选择任期为 3 的绿色条目
- 合并完成后，S1成为新的领导者并提供服务