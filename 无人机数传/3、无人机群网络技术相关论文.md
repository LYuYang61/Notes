# 3、无人机群网络技术相关论文
## 一、A Novel Consensus-Based Distributed Time  Synchronization Algorithm in High-Dynamic  Multi-UAV Networks
### 1、研究问题
- 多无人机网络的时间同步是数据协同、任务调度和数据融合的先决条件。然而，当无人机处于高速机动状态时，传统的同步方法面临两大挑战：
	- **高动态性引起的时延偏差**： 无人机的高速运动会产生显著的相对径向速度（vij​），导致信号传播时间（即时延）发生变化，进而引入较大的时钟参数估计误差
	- **分布式共识与高动态性的冲突**： 现有的基于共识的同步方案大多未能充分考虑节点间的动态变化，甚至假设节点静止，这在高动态环境中会迅速失效
- **本文核心贡献**：
	1. 基于平均共识理论提出一种适用于高动态 UAV 网络的**逻辑时钟参数更新模型**
	2. 提出 **DATJ（Doppler + Timestamps Joint）算法**：联合利用多普勒信息与多轮时戳来同时估计相对时钟偏差（skew）与偏移（offset），并把估计结果融入分布式共识更新
	3. 给出了严格的**收敛性证明**（相对参数、逻辑时钟偏差/偏移及最终逻辑时钟的有界收敛），并通过仿真实验证明 DATJ 在高动态场景下优于 LSTS 和 SSTS 等现存方法
---

## 二、A Lightweight Consensus Mechanism for  Large-Scale UAV Networking
### 1、研究问题
- 大规模无人机群在资源受限、拓扑快速变化与不安全无线环境下，如何高效、可扩展且安全地达成**数据一致性**，以支撑群体式决策与任务协同
- 本文提出了一种面向大规模无人机集群的轻量级共识机制：
	- 根据无人机集群的**运动相似性对其进行聚类**，以保持集群的稳定性
	- 设计了一种**基于 Frost 的 HotStuff 共识协议**，利用 Frost 的低资源消耗实现轻量级共识
	- 采用了跨簇共识机制，**簇内共识和簇间共识工作在流水线模式下**，从而实现了高效的数据共识
### 2、系统模型
- 本文提出的模型以无人机辅助智能电网为参考
- 在该场景中，无人机集群被划分为多个集群，每个集群都有其各自的责任区域，它们从各自指定的区域收集信息，为电力调度、电网规划等决策提供数据支持
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20251002110150.png)
- **集群成员无人机**：
	- 是集群内的普通无人机节点，除集群头无人机外的所有无人机均为集群成员无人机
	- 主要任务是参与集群内共识，使集群内所有节点对接收的外部数据达成一致
- **集群头无人机**：
	- 可由集群内的节点根据其移动性、计算能力和存储容量进行选择
	- 作为无人机集群的一员，与集群内的其他节点共同参与集群内共识
	- 为了与其他集群共享数据，集群头节点还会与其他集群的集群头形成集群间共识网络，以进行集群间共识
### 3、基于运动相似性的稳定性聚类（创新点 1）
- 在多无人机分布式网络中，节点的**高速移动**会导致网络拓扑频繁变化，如果用传统聚类方法（比如基于节点 ID 或 KMeans），容易出现：
	- UAV 频繁切换簇（cluster-switching），导致需要重新选簇头、重新建立共识组
	- 消耗大量通信资源，增加共识延迟，甚至引发共识失败
- 本文提出一种**与节点运动特性相关的稳定聚类方法**，让簇的形成尽可能反映 UAV 的自然运动规律，减少拓扑抖动
- **核心思路**：
	- 如果两个 UAV 的**运动方向、速度和初始位置都相似**，那么它们未来更可能保持连通
	- 本文把这三方面结合起来，设计了一个**运动相似度函数 Sim (I, J)**，作为是否归为同簇的依据
- **聚类判定与流程**：
	- 所有 UAV 在起飞时**广播一次**自己最近 t 个速度向量和位置
	- 每个节点都能计算出所有 UAV 两两之间的 Sim (I, J)
	- 给定阈值 T，如果 $Sim(I,J)≥T$，则 UAV i 和 j 属于同一簇，否则，分配到不同的集群中
	- 最后得到一个**相似度矩阵**（每对 UAV 的相似度），从而快速划分簇
- **关键点**：只需要“一轮广播”即可完成聚类（通信开销极低）
### 4、FHotStuff：协议合成实现资源优化（创新点 2）
#### 4.1 HotStuff 基础与 Frost 引入的动机
- **HotStuff** 是一种拜占庭容错（BFT）分布式共识算法，采用领导者选举和状态机复制机制，核心思想：
	- **三阶段提交（prepare, pre-commit, commit）** → 保证安全性
	- **Chained HotStuff**（链式） → 通过流水线化把三个阶段串接起来，提高吞吐，适用于节点数量较多的场景
	- 依赖**阈值签名**（threshold signature）来形成 QC（Quorum Certificate），即某个区块在 ≥2/3 节点投票后被认为有效
- 然而，HotStuff 在每个共识轮次中都需要多次聚合签名计算以生成 QC，这导致了较高的计算复杂度和通信开销
- 为了在资源受限的无人机环境中进一步优化这一开销，本文提出了 **FHotStuff**，通过集成**灵活的轮次优化 Schnorr 阈值签名 (Frost)** 来降低资源消耗
#### 4.2 Frost 的特点与挑战
- **Frost** 作为 Schnorr 签名的变体，具有**签名尺寸小和验证速度快**的特点，是实现轻量化共识的理想选择，但是存在两个主要缺点：
	- **通信开销**：它通常需要两轮通信（第一轮传输 Nonce 和 Commitment，第二轮传输部分签名）才能完成一次签名
	- **非鲁棒性**：任何参与者在签名过程中的恶意行为都可能导致签名失败，需要重新生成 Nonce 和 Commitment，从而造成资源浪费
- **FHotStuff** 的核心任务正是通过协议的巧妙设计，消除 Frost 的两轮通信延迟，并高效地解决其非鲁棒性问题
#### 4.3 机制一：安全的分布式密钥生成（DKG）
- FHotStuff 采用的是基于 **Pedersen DKG** 的变体，并增加了额外的安全机制以抵御特定攻击
- 整个过程的核心目标是让集群中的 N 架无人机共同生成一个群组公钥 Y，并为每架无人机分发一个私有签名份额 si​，且在整个过程中，完整的私钥从不出现于任何单一节点
- 由于系统需要容忍最多 1/3 的恶意无人机，因此签名所需的门限 T 被设定为 $\lfloor 2n/3 +1\rfloor$
##### 1、阶段一：密钥份额的准备与承诺（Commitment）
1. **多项式秘密分享**：
    - 集群内的每架无人机 Ui​ 独立选择一组随机数作为系数，并用它们构造一个**秘密多项式**fi(x)
    - 这个多项式的常数项构成 Ui​ 对最终群组私钥的贡献
2. **生成公开承诺和知识证明（核心安全机制）**:
    - Ui​ 根据其多项式的系数，计算出一个**公开承诺列表**（Ci​），公开承诺了 Ui​ 多项式的形状，但并未透露其私有系数 
    - 为了抵御**流氓密钥攻击**（即恶意节点提交一个看似有效但实际上会破坏签名的承诺），Ui​ 必须附带一个**知识证明**（σi​），这个证明向所有节点保证，其公开承诺确实是根据它所声称的私有系数生成的
##### 2、阶段二：信息广播与互相验证
1. **广播承诺和证明**：
    - 每架无人机 Ui​ 将其生成的**公开承诺列表**（Ci​）和**知识证明**（σi​）广播给集群内的所有其他无人机 
2. **验证承诺的真实性**：
    - 接收到消息的其他无人机，会立即使用知识证明 σi​ 来**验证** Ui​ 发送的承诺列表 Ci​ 的正确
    - 只有验证通过，才能确保 Ui​ 没有试图作弊，提交一个可能导致后续签名失败的“流氓密钥”
##### 3、阶段三：私有份额的发送与密钥组装
1. **秘密份额交换（Shamir 秘密分享）**：
    - 一旦承诺被验证为正确，每架无人机 Ui​ 就会根据其私有秘密多项式 fi​(x)，计算出发送给其他每一架无人机 Ul​ 的**私有份额** fi​(l) 
    - Ui​ 将这些份额通过加密（或安全通道）私密地发送给对应的 Ul​
    - Ul​ 收到份额后，会再次进行验证，确保该份额与 Ui​ 之前广播的公开承诺列表一致 
2. **计算长期密钥**：
    - 每架无人机 Ui​ 收集所有其他无人机发送给它的私有份额 fl​(i)
    - Ui​ 将所有收集到的私有份额求和，最终得到自己的**长期私有签名份额** si​ 
    - 同时，集群中的所有无人机都可以根据公共信息计算出最终的**群组公钥** Y 以及每个参与者的**公有验证份额** Yi​
##### 4、预计算 Nonce 和 Commitment
- **常规 Frost 挑战**：原始的 Frost 签名机制需要额外的两轮通信来交换 Nonce 和 Commitment，这会增加延迟
- **FHotStuff 优化**：在共识开始前，所有无人机预先生成足够数量的 **Nonce**（用于签名计算的临时秘密值），并计算出对应的**承诺份额**
- **预分发和索引**：
	- 这些承诺份额被预先广播给集群内的所有节点并储存在本地
	- 在实际共识阶段，节点无需发送完整的 Commitment（可能高达数十字节），而只需发送一个 **1 字节的索引**来引用本地存储的 Commitment
- 通过这种方式，FHotStuff 巧妙地将 Frost 签名过程中原本昂贵的两轮通信成本，转移到了资源消耗较低的系统初始化阶段，从而在实际的共识循环中实现了极低的通信开销
#### 4.4 机制二：Frost 与 HotStuff 的集成
- FHotStuff 通过**将 Frost 的签名过程无缝融入 HotStuff 的提案-投票**（Proposal-Vote）循环中，消除了 Frost 固有的额外通信轮次，从而提高了共识效率并减少了通信延迟
##### 1、阶段一：领导者发布提案 (Proposal)
- **动作**：在每一轮共识中，当前领导者将客户端数据和上一轮生成的 **QC**（仲裁证书）打包成一个新的 **Proposal**（提案），并将其广播给集群内的所有副本节点。
- **提案结构**：提案中包含用于下一个 QC 的 **Commitment 索引列表** + 客户端数据 + 上一轮生成的 **QC**
##### 2、阶段二：副本节点验证与投票 (Vote)
- 副本节点收到 Proposal 后，执行以下步骤：
	1. **提案验证**：副本节点首先验证 Proposal 中携带的 **QC** 的签名是否正确，以确认该提案的合法性
	2. **提取参与者**：副本节点从 Proposal. QC 中的 **Commitment 索引列表**中，提取出参与本轮投票的节点及其 Commitment 索引 
	3. **计算部分签名**：
	    - 如果副本 i 在该列表中，它会利用本地存储的**长期私钥份额** si​ 和预计算好的 **Nonce** (di​, ei​) 
	    - 副本 i **一步计算**出自己的**部分签名** zi​
	    - 原本 Frost 需要额外一轮通信来确定 Commitment，现在 Commitment 已经被预先分发并包含在 Proposal 的索引中，使得副本节点可以直接进入部分签名计算环节，**避免了额外的通信延迟** 
	4. **发送投票消息（PartialSigQC）**：副本 i 将这个部分签名 zi​ 和**下一个未使用的 Commitment 索引**封装成一个 **PartialSigQC** 投票消息，发送给 Leader
##### 3、阶段三：Leader 聚合签名与生成 QC
1. **验证部分签名**：Leader 收到投票后，会验证每个部分签名 zi​ 的正确性
2. **签名聚合**：Leader 收到至少 $\lfloor 2n/3 \rfloor$ 个（即超过 2/3 阈值）正确的部分签名后，将它们聚合成一个总签名 $z=\sum z_i​$
3. **生成 QC**：Leader 将总签名 z 和新的 Commitment 索引列表打包成一个新的 **QC**（仲裁证书），用于下一个 Proposal
#### 4.5 应对 Frost 非鲁棒性：超时处理与重排序
 - Frost 的缺点是非鲁棒性，本文提出了两个机制来缓解：
	 - **超时处理**：
		 - 如果某一轮签名失败（比如某节点提交错误 commitment 或未及时响应），节点**将最新的 prepareQC 封装成 New-View 消息发送给下一任 Leader**
		 - 新 Leader 接收到足够的 New-View 消息后，不会要求所有节点重新生成新的 Nonce 和 Commitment（传统方案），而是会对 Commitment 索引列表进行重排序
    - **重排序**：
	    - 把发送了**正确 New-View 消息的节点**（表明其状态正常）对应的 Commitment 索引排在列表头部
	    - 把可疑或失败的节点放到后面或延迟使用
- 这种机制确保了在下一轮共识中，Leader 优先使用可靠、在线的 Commitment 来生成签名
### 5、多集群并行与全局数据一致性（创新点 3）
#### 5.1 跨集群共识的流水线协同模式
##### 1、机制运行模式
- 集群内共识协议和集群间共识协议是**独立运行且互不干扰**的，这种模式允许工作像工厂的流水线一样连续不断：  
	1. **集群内共识**：
		- 当一个集群（如 C1）收到客户端数据 TXj​ 后，CH1（假设为当时的 Leader）发起集群内共识
		- 集群内所有成员使用 FHotStuff 协议进行三轮投票（PREPARE, PRECOMMIT, COMMIT），目标是达成局部一致
	2. **触发全局共识（流水线启动点）**：
		- 当集群头 CH1 检测到集群内共识已经进入**Decide Phase**（决定阶段，意味着局部数据已确定）时，CH1 **立即**将该数据转发给集群间网络
		- 此时，CH1 充当集群间共识网络中的**客户端**角色
	3. **集群间共识**：
		- 此时集群间网络的 Leader（例如 CH2）接收到 TXj​，并针对该数据发起集群间共识，与其他 CHs 共同对全局事务达成一致
	4. **非阻塞并行**：
		- C1 集群内的节点无需等待集群间共识的结果，即可立即启动针对下一个请求 TXj+1​ 的集群内共识
		- 这种流水线模式使得系统能够连续不断地处理事务，从而显著提升了事务处理的吞吐量
##### 2、全局数据分发
- 当集群间共识完成 TXj​ 的最终确认后，会进行数据分发 ： 
	- **源集群反馈**：发起数据 TXj​ 的集群的集群头（CH1）向其集群成员广播一个成功信号
	- **跨集群同步**：其他集群的集群头则将该数据发送给各自集群的成员，以便这些集群的成员也能执行该请求，达到最终全局一致

![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20251003171134.png)

- 上图展示了四个集群（C1, C2, C3, C4）在处理四个连续事务 TXj​ 到 TXj+3​ 时的流水线过程
- 图中的**黑色 BFT** 代表**集群内共识**，**蓝色 BFT** 代表**集群间共识**，**橙线**代表**簇头** CH1，CH2，CH3 和 CH4
#### 5.2 通过集群间共识保证请求执行顺序一致性
- 由于每个集群是独立运行的，并且各个集群接收客户端请求的顺序可能不同，这就会导致一个严重的**全局一致性**问题：不同集群对同一个数据块上的事务执行顺序可能不一致
- 为了解决这个挑战，本文提出了一个简洁而有效的方法：
	- **统一路径原则**：所有的请求数据，无论是直接被集群内部接收，还是由集群头从其他集群转发而来，都**必须经过集群间共识阶段**才能达到最终的一致性
	- **全局排序依据**：在集群间共识阶段，请求数据将根据其**进入该阶段的先后顺序**进行严格排序
	- **一致性保证**：一旦集群间共识确定了请求的全局顺序，集群头就会将这个排序结果或数据广播给其集群成员，成员们会严格按照这个**统一的顺序**执行请求并更新链数据
- 这种设计保证了整个大规模无人机集群对所有事务的最终执行顺序是一致的，从而严格维护了系统的安全性
---

## 三、ACBFT: Adaptive Chained Byzantine Fault-Tolerant  Consensus Protocol for UAV Ad Hoc Networks
### 1、研究问题
- 如何在高移动性、资源受限的 UAV 网络中，设计一个既能容忍拜占庭节点又能高吞吐、低延迟、并适应拓扑变化的轻量级区块链共识协议
- 本文提出了一种专门为无人机网络环境量身定制的**自适应链式拜占庭容错 ( ACBFT ) 协议**：
	- 利用**粒子群优化** ( particle swarm optimization，PSO ) **算法对链式共识过程进行优化**，增强了鲁棒性，降低了通信开销
	- 提出了几个子协议来协助 ACBFT 处理突发状况，包括**管理恶意节点的重链协议，动态节点的加入和退出协议，以及处理无人机丢失**等意外情况的策略
### 2、系统模型
- ACBFT 的运行环境基于 **UAV Ad Hoc 网络**，这是一种多跳无线基础设施，网络中的每个 UAV 都兼具移动无线终端和路由器的双重功能
- 从逻辑层面看，整个 UAV 集群被抽象为一个基于移动自组织网络原则的**点对点（P2P）虚拟网络**
- **共识节点划分策略**：
	- 整个 UAV 集合 U 由 M 个 UAV 组成，**只有成功通过认证的 UAV 才能请求加入共识网络 P**，后者包含 N 个实际参与共识过程的共识节点 Pi​ 
	- 这种 P⊂U 的设计，使得资源受限的 UAV 可以选择不参与资源密集型的共识过程
- 共识网络拓扑通过**共识节点距离矩阵** 来表示，矩阵中的元素 $x_{i,j}​$ 代表共识节点 $P_i​$ 和 $P_j$ ​ 之间的**最短路由距离**，即在当前拓扑下的最短跳数
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20251004173556.png)
- **动态操作对拓扑的影响**：本文详细列举了多种会影响网络拓扑并可能导致距离矩阵发生变化的原子操作 ：  
	- 新的 UAV 加入或退出认证网络 U
	- UAV 从 U 加入或退出共识网络 P
	- UAV 意外丢失（无论是 P 内还是 U 内）
	- UAV 物理位置变化导致的拓扑重构
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20251004175006.png)

- **UAV 区块链的结构被概念化为由哈希值相互连接的数据块序列，形成了链状结构**，主要由区块头（Block Header）和区块体（Block Body）组成
	- **区块头**：包含与当前区块相关的元数据，如版本号、前一区块的哈希值、时间戳、以及**Merkle Root** 等
		- **Merkle Root** 是通过哈希树计算出的根哈希值，其作用是**简洁地代表区块体内所有事务数据**
		- 它提供了一种高效的验证机制，以确保数据的完整性和一致性
		- 由于区块哈希值由区块头的各项信息（包括前一区块哈希值和 Merkle Root）生成，任何对事务数据的篡改都会通过哈希链向后传播，从而有效防止数据被篡改
	- **区块体与事务（TX）**：
		- 区块体包含交易数据，在 ACBFT 系统中，交易主要由 UAV 之间的**非人为交互数据**构成
		- 一个基本的事务（TX）包含发送方 ID、公钥、MAC 地址，以及接收方的相应信息、时间戳、数据类型和实际数据内容等
		- 系统使用公钥签名、消息认证码（MACs）和哈希函数生成的**消息摘要**等加密技术，来确保消息的安全性和有效性 
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20251004175055.png)

### 3、基于 PSO 的自适应链排序优化（创新点 1）
#### 3.1 正常执行下的节点划分与共识流程
- 在正常的共识执行过程中，共识网络 P 中的 N 个节点被划分为两部分，旨在平衡性能与容错能力
	1. **链节点集 (Ω)**：包含 2f+1 个 UAVs，它们主动参与核心的链式共识过程
	2. **备用链节点集 (Ψ)**：包含 f 个UAVs，主要负责维护同步信息
- 这里的划分遵循拜占庭容错标准，即在总节点数 N=3f+1 的情况下，系统能够容忍最多 f 个恶意节点
- **正常共识流程**主要分为两个阶段：
##### 1、链节点共识 Chain Node Consensus
- 客户端（通常是接收数据的 UAV）将事务打包后发送给链中的**头节点** $P_1$
- 头节点验证交易的正确性后，为其分配序列号 (SN)，并形成一个 **(CHAIN) 消息**
- 该消息包含**视图编号 (VN)、序列号 (SN)、重链次数 (RV)、交易 (TX)、客户端 (C)、执行历史和结果的哈希值 (HH, HR)**，以及最重要的**当前链序 (CO)** 
- 随后，头节点沿链式顺序将 (CHAIN) 消息转发给其继任者 $P_2​,...,P_{2f+1}​$ 
- 关键机制在于，每当前驱节点 $P_{i−1}​$ 向后继节点 $P_i$ ​ 发送消息后，它会立即**启动一个计时器**，用于管理潜在的故障并确保系统的活跃性
- 当消息到达**尾节点** $P_{2f+1}$ 时，尾节点计算其签名，并**将包含所有参与节点签名的 (REPLY) 消息发送回客户端**
- 客户端只有在收到包含链中所有节点签名的 (REPLY) 消息后，才会确认事务完成
##### 2、取消计时器 Cancel the Timer
- 当尾节点 $P_{2f+1}$ 完成共识后，它会执行同步操作：
	1. **同步备用节点**：$P_{2f+1}$ 将 (CHAIN) 消息发送给备用集 Ψ 中的所有节点，使其状态同步
	2. **确认与计时器取消**：
		- $P_{2f+1}$ 同时向其前驱节点 $P_{2f}$ 发送一个 (ACK) 确认消息，<ACK, VN, SN, CO, HT, C>$σ_{2f+1}$ ​
		- $P_{2f}​$ 收到 (ACK) 消息后，**立即取消其为等待 $P_{2f+1}$ 响应而设置的计时器**，并将 (ACK) 消息转发给其前驱节点
		- 该过程沿链持续，直到 (ACK) 消息到达头节点 $P_1$ 
	3. 头节点 $P_1$ 收到 (ACK) 消息后，也会向 Ψ 中的节点发送相应的 (CHAIN) 消息，**确保 Ψ 节点基于头尾节点的信息进行状态同步**
#### 3.2 PSO-Based 链排序算法
- 链中节点的顺序（链序）对共识效率具有决定性影响，如果相邻节点之间的**跳数 (Hop Count)** 过多，将显著增加通信延迟和复杂度
- ACBFT 采用**粒子群优化 (PSO) 算法**来确定最优链序 
- PSO 是一种进化算法，其优势在于**收敛速度快、所需的参数少且易于实现** 
- 与依赖梯度信息的传统图论算法相比，PSO具有**更低的复杂度**和**更强的全局搜索能力**，并且其并行计算能力使其更适合处理大规模问题
- **目标函数的最小化**：链序优化的目标是最小化在一次共识过程中所需的**总通信跳数**，Fitness Value F 被定义为总跳数的数学表达式：
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20251005105707.png)
- 第一项计算核心链节点集 Ω 内部链式传播所需的总跳数
- 第二项计算尾节点 $P_{2f+1}$ 向备用节点 Ψ 传输同步信息所需的总跳数
- 第三项计算头节点 $P_1$ ​向备用节点 Ψ 传输同步信息所需的总跳数
- 最小化 F 意味着最大化通信效率，从而减少 UAV 网络中的信号冲突和延迟
- **链序的不可预测性带来的安全优势**：
	- 尽管 PSO 算法作为一种群体随机优化技术，可能陷入局部最优解，但该特性反而成为协议的一项安全优势
	- PSO 算法得到的链序具有一定程度的**不可预测性**，使得潜在的攻击者无法提前预测链序来预谋攻击
	- 这种特性将算法在数学优化上的潜在缺陷转化为了系统在网络安全上的鲁棒性  
- PSO-Based 链排序算法的时间复杂度为 O (M⋅N)，其中 M 为迭代次数，N 为粒子数量

### 4、鲁棒性与动态性处理子协议（创新点 2）
#### 4.1 重链协议与恶意节点处理
- 重链协议旨在在恶意节点存在的情况下维护 ACBFT 的**活跃性**，并确保所有可疑或恶意节点最终被识别并隔离
- 为了实现准确的故障检测和最小化共识延迟，重链协议引入了基于位置的计时器 $Π_i​$：
	- 对于链中的节点 $P_i​$，其计时器 $Π_i​$ 定义为 $Π_i​=(N−f−i)δ$，其中 δ 是可根据网络状态调整的基准时间
	- 如果 $P_i​$ 的计时器 $Π_i​$ 超时，则 $Pi​$ 怀疑其后继节点 $Pi+1$ ​存在恶意延迟或断连，它将**向头节点和其前驱节点发送 (ACCUSE) 消息**，<ACCUSE，AA，RV，VN>$σ_i$ 【AA 是由指控方 $P_i$ 和被指控方 $p_{i+1}$ 组成的元组 】
	- 为了防止恶意节点进行虚假指控，协议设定 $Pi​$ **只能指控其直接的后继节点** $P_{i+1}​$ 
- 当头节点收到 (ACCUSE) 消息后，它会启动**重链算法**：
	1. **恶意节点处理**：除非指控方是头节点 $P_1$ ​，否则**指控方和被指控方 ($P_x$ ​ 和 $P_{x+1}$) 都将被移至备用节点集 Ψ 的末端**
	2. **链序重构**：核心链 Ω 中被移除节点的位置由后续节点向前递补，确保 Ω 保持 2f+1 个节点的规模
	3. **重新计算**：重新分配节点后，系统调用 PSO-Based 链排序算法重新计算新的最优链序
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20251005172033.png)

- **重链次数与恶意节点数量的关系**：在最坏情况下，如果存在 t 个恶意节点且头节点正确，则所需的重链次数与恶意节点数量 t 成正比，而不是与最大容错数 f 成正比 ：  
	1. 当 2t ≤ f 时，恶意节点将在 t 次重链后被全部移至 Ψ 
	2. 当 2t > f 时，仍需要 t 次重链，其中 2t−f 个节点需要通过**重配置机制**进行修复 
#### 4.2 检查点和视图变更
- **检查点协议**：
	- 鉴于 UAVs 的存储容量有限，需要定期将已打包的数据块卸载到地面基站
	- 检查点协议采用链式方式运行，**必须在数据卸载前执行**，以保证卸载信息的一致性 
	- 此外，为了解决头节点和尾节点传输给备用节点  Ψ 的事务信息可能不一致的问题，Ψ 中的节点被允许**周期性地查询**其他链节点（非头尾节点）来同步共识事务信息
- **视图变更协议**：
	- 用于处理头节点故障或恶意行为
	- 恶意头节点可能故意设置**高延迟链序**，从而拖慢整个共识速度
	- 为了检测这种性能攻击，ACBFT的每个节点都会根据其链序设置一个**性能计时器** $Π_i^v​$
- 当正确节点 $P_i$ ​ 怀疑头节点失败（例如 $Π_i^v​$ ​过期）时，它**发起视图变更，并向所有节点发送 (VIEWCHANGE) 消息**
- 一旦新头节点收到 2f 个 (VIEWCHANGE) 消息，它将广播 (NEWVIEW) 消息，并开始生成新的 (CHAIN) 消息，从而切换到新的视图并恢复共识
#### 4.3 共识节点变更协议
- 为应对 UAVs 的动态加入、退出或意外丢失，ACBFT 设计了节点变更协议，这些请求会被系统**优先处理**
##### 1、JOIN（加入）请求处理
- 新 UAV $U_j​$ 经过认证后，基站或 $U_j​$ 向头节点发送 (JOIN) 请求
- 头节点接收请求后，会**临时暂停当前事务的共识过程**，验证签名并通过链式传播达成共识
- 根据节点变更算法，头节点会根据当前共识节点数 N 和容错 f 谨慎调整 $U_j​$ 的位置：
	- 如果 $N mod 3==1$（保持 N=3f+1 的容错结构），新节点 $U_j$ ​ 被置于 Ψ 的末端 $P_N$ ​，容错能力 f 增加 1
	- 如果 $N mod 3!=1$，新节点 $U_j$ ​ 被插入到 Ω 和 Ψ 之间的特定位置，随后调用 PSO-Based 链排序算法重新计算链序
##### 2、EXIT/LOSS （退出/丢失）请求处理
- 当 UAV $U_j​$ 退出或因事故丢失时，基站或检测节点发送 (EXIT) 或 (LOSS) 消息给头节点，请求被优先处理
- 对应的节点 $P_i$ ​ 被移除后，后续节点向前递补，头节点同样根据 N 和 f 的关系进行调整，并在必要时重新计算链序
#### 4.4 UAV 网络拓扑变化处理
- UAV 集群的物理位置变化或节点失联会导致共识节点距离矩阵发生改变，头节点负责实时监控并更新拓扑结构
- 头节点计算距离矩阵的变化量 $ε' = ε_{new} − ε_{old}$，并通过度量 $Q=1^T ε'1$（其中 1 是维数为 N 的全 1 列向量）来量化拓扑变化的总影响 
- 如果该变化度量  Q≥N（共识节点数量），系统将判断拓扑变化足以影响共识效率，从而触发  PSO-Based 链排序算法**重新计算最优链序** 

### 5、无重配置方案 ACBFT5
- 在某些特殊应用场景中，UAV 网络可能无法依赖外部重配置方案。为此，本文提出了**ACBFT 5**方案，该方案旨在**无需重配置**的情况下，仍能高效稳定地运行
- ACBFT5 借鉴了拜占庭仲裁协议的原理，旨在容忍 f 个拜占庭故障，但要求更高的总节点数 N=5 f+1
- **节点集组成**：在 ACBFT5 中，核心共识集 Ω 被扩大到 3f+1 个节点，而备用节点集 Ψ 包含剩下的 2f 个节点
- **重链机制**：ACBFT5 沿用与 ACBFT 相同的重链逻辑，即迅速将指控方和被指控方移至链尾，但它们的具体重定位位置是 $P_{5f}$ ​ 和 $P_{5f+1}​$  
- **高稳定性**：这种节点配置和重链机制确保了即使存在 f 个故障节点，ACBFT5**至多只需 f 次重链**即可将所有故障节点移至 Ψ 集合，从而保证系统的持续和稳定运行，无需外部干预或重配置
